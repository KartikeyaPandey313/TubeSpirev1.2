# ==============================================================================
# /.github/workflows/lighthouse.yml (Production Grade)
#
# This GitHub Actions workflow automates website quality assurance by running
# a Lighthouse CI audit on every push to the 'main' branch. Lighthouse tests
# for performance, accessibility, best practices, and SEO.
#
# If any score falls below the defined thresholds, the build will fail,
# acting as a quality gate to prevent regressions in production.
# ==============================================================================

# Workflow name displayed on the GitHub Actions tab.
name: Lighthouse CI Audit

# Defines the trigger for this workflow.
on:
  # Triggers on push events to the 'main' branch.
  push:
    branches: [main]
  # Allows the workflow to be run manually from the Actions tab for on-demand checks.
  workflow_dispatch:

# Defines the jobs to be run as part of the workflow.
jobs:
  lighthouse:
    name: Lighthouse Audit
    # Specifies the runner environment. 'ubuntu-latest' is a standard, cost-effective choice.
    runs-on: ubuntu-latest
    # A sequence of steps that make up the job. Each step runs a command or an action.
    steps:
      # Step 1: Check out the repository code.
      # This action downloads your code onto the runner so it can be accessed.
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: Set up the Python environment.
      # This action installs a specific version of Python required to run the Flask app.
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # Step 3: Install Python dependencies.
      # This reads the requirements.txt file and installs all necessary libraries (Flask, yt-dlp).
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      # Step 4: Set up the Node.js environment.
      # Lighthouse is a Node.js tool, so this step is required to run it.
      - name: Use Node.js 18.x
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: "npm" # Caches npm packages for faster subsequent workflow runs.

      # Step 5: Install the Lighthouse CI command-line tool globally on the runner.
      - name: Install Lighthouse CI
        run: npm install -g @lhci/cli@0.12.x

      # Step 6: Start the Flask application in the background.
      # We use Gunicorn, a production-grade WSGI server, to run the app robustly.
      - name: Start Flask server
        run: |
          # The '&' symbol runs the server process in the background.
          gunicorn -w 1 app:app &
          # We wait for a few seconds to ensure the server is fully initialized before testing.
          sleep 5

      # Step 7: Run the Lighthouse CI audit against the live, local server.
      - name: Run Lighthouse CI
        id: lhci # Give this step an ID to reference its outcome later.
        run: |
          # The '|| true' at the end is a crucial trick. It ensures this step doesn't
          # immediately fail the entire workflow if the audit scores are too low.
          # Instead, it allows the workflow to continue to the next steps, and we
          # will check the outcome manually in the final step.
          lhci autorun \
            --collect.url=http://127.0.0.1:8000/ \
            --upload.target=temporary-public-storage \
            --assert.preset=lighthouse:recommended \
            --assert.assertions.'categories:performance'.minScore=0.9 \
            --assert.assertions.'categories:accessibility'.minScore=1 \
            --assert.assertions.'categories:best-practices'.minScore=1 \
            --assert.assertions.'categories:seo'.minScore=1 || true
        env:
          # This secret is needed for Lighthouse to post status checks on pull requests.
          # It must be configured in your GitHub repository settings.
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}

      # Step 8: Stop the Flask server.
      # The 'if: always()' condition ensures this step runs even if the Lighthouse audit
      # or any other previous step fails. This is important for cleanup.
      - name: Stop Flask server
        if: always()
        run: |
          # Finds the Gunicorn process by name and stops it gracefully.
          pkill gunicorn

      # Step 9: Upload the Lighthouse report as a build artifact.
      # This saves the detailed HTML reports, which can be downloaded and viewed
      # from the GitHub Actions summary page for debugging.
      - name: Upload Lighthouse report artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: lhci-report
          path: .lighthouseci/

      # Step 10: Check the Lighthouse results and fail the job if necessary.
      # This is our quality gate. It checks the outcome of the 'lhci' step.
      # If the assertions failed, this step will execute and cause the entire job to fail.
      - name: Check Lighthouse results
        if: steps.lhci.outcome == 'failure'
        run: |
          echo "Lighthouse CI assertions failed. Check the 'lhci-report' artifact for details."
          exit 1
